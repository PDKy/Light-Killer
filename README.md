# Light-Killer
Meta战队视觉算法


LK0.4概况
经过前一段时间的折磨，现在已经勉强可以用了 😅 现在进行下整体介绍

#1 "eli_white()" 是消白光算法 由于之前使用RGB颜色空间进行图像分析，白光由于在RGB通道中都是满的，对后续图像处理（尤其是二值化处理部分）有较大影响，所以思考先将
白光消去，但是算法采用以逐个访问像素点的方法😅🤡导致前期程序运行非常缓慢，后来使用item()指令访问每个像素点使速度有一定提升，但还是太慢，所以这个函数不要使用

#2 "HSV()" 将RGB转为HSV颜色空间（H为颜色，S为饱和度，V为明度）并对红色进行二值化处理。其实RGB中的R通道并不能很好的表示现实生活中的所有红色，比如你拿灯光照一下一个只有红色通道的像素点
光照后的像素点在B和G通道中会产生值，所以比较难用RGB颜色空间分练出所有的红色，那么采用HSV颜色空间，它很好的描述了灯光与颜色的关系（通过引入饱和度和明度），在HSV颜色通道下，每个像素点
有三个值[H,S,V] 分别对应颜色，饱和度，明度。红色的范围是：[0, 43, 46]~[10,255,255]∪[156, 43, 46]~[180,255,255]。可以很清楚的看到我在代码中写的：
    lowred1 = np.array([0,43,46])
    upred1 = np.array([10,255,255])
    lowred2 = np.array([156,43,46])
    upred2 = np.array([180,255,255])
cv2.inRange(图像矩阵，lower,upper)就是二值化指令，将像素点的HSV值在lower和upper之间的设为1，其余设为0，输出的是一个图像矩阵，那么这样我们就能很好的将红色分练出来

#3 "expend()" 膨胀函数。为了消除离散的像素点，使得后续边框检测更好进行
    kernel = cv.getStructuringElement(cv.MORPH_RECT, (5, 5))  其实这东西就是用了一个卷积算法，（5，5）是卷积核大小
    dst = cv.dilate(img, kernel,3)  3是膨胀次数
    
#4 "rank(contours,hierarchy)" 重量级算法😅 用来分练轮廓的。根据观察，我们所检测的目标是一个只有唯一父轮廓的轮廓，这个算法就是将符合这个条件的轮廓全部找出来
具体怎么实现的，以后再写，现在累了😅，由于现实的复杂性，符合此条件的轮廓可能不只一个，所以又带了一个辅助检测
if cv.contourArea(contours[i]) >= cv.contourArea(contours[m[0]]): 利用面积条件检测
但其实有时候还是找不到符合这样条件的轮廓，很大原因是灯光，那么就要用另一个次级检测函数 findthetarget(contours,hierarchy)

#5 "findthetarget(contours,hierarchy)" 该函数就是找到一个四边形轮廓，然后利用面积特征找到目标。
a = cv.approxPolyDP(i,5, True)  "i"是轮廓矩阵  5是表示拟合精准度，越小越精准，len(a)就是i这个轮廓矩阵经过算法拟合后的多边形边数，

以上就是0.4版本最重要的东西

0.4=》0.5改进思路： 用先将红色全部提取出来  然后用聚类算法 （KNN? FCM？） 分练出轮廓
                    原因  因为在HSV中红色范围过大，偏红的地方都会被视为潜在对象，所以考虑用分类算法，将大幅红色分为一类，大幅的红色一般灯光源是模拟不出来的
                    潜在问题：需要内存过大？？在jetson上跑会很卡？？？？？建议买性能高点的  LZZ赶紧打点钱  😅//
